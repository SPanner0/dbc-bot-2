pub mod owner_commands;
pub mod manager_commands;
pub mod user_commands;

use crate::{api::{BrawlStarsApi, GameApi}, database::{Database, PgDatabase}, tournament_model::{SingleElimTournament, TournamentModel}, BotError, Data};

/// A way to group commands together while side-stepping the need to use global variables.
///
/// Implementors of this trait can return a list of their commands from within their own module.
/// Typically, you would group commands by their required permissions or role.
///
/// Additionally, the implementors of this trait should not directly "own" the commands.
/// You should simply generate them by running the functions generated by the [`poise::command`](https://docs.rs/poise/latest/poise/macros/attr.command.html) macro and returning the vector.
/// This way, you only need to `pub` the implementor and not the commands themselves.
///
/// For more details on how this works, you can check the documentation for the [`poise::command`](https://docs.rs/poise/latest/poise/macros/attr.command.html#internals) macro.
///
/// For example, you can define a type to group Manager commands together.
/// ```
/// pub struct ManagerCommands; // This struct doesn't need to hold anything
///
/// impl CommandsContainer<PgDatabase, SingleElimTournament> for ManagerCommands {
///     fn get_commands_list(&self)
///         -> Vec<poise::Command<BotData<PgDatabase, SingleElimTournament>, BotError>> {
///         vec![very_important_manager_only_command()]
///     }
/// }
///
/// #[poise::command(slash_command, prefix_command)]
/// async fn very_important_manager_only_command(
///     ctx: Context<'_>,
/// ) -> Result<(), BotError> {
///     ctx.say("Wow, you're a manager, that's so cool!").await?;
///     Ok(())
/// }
/// ```
pub trait CommandsContainer<DB, TM, P>
where
    DB: Database,
    TM: TournamentModel,
    P: GameApi
{
    /// Retrive all the commands from a module, such as manager commands or marshal commands.
    fn get_commands_list() -> Vec<poise::Command<Data<DB, TM, P>, BotError>>;
}

pub(self) mod checks {
    use poise::CreateReply;

    use crate::{BotError, Context};

    pub async fn is_manager(ctx: Context<'_>) -> Result<bool, BotError> {
        let guild_id = ctx
            .guild()
            .ok_or("This command can only be used in a server.")?
            .id
            .to_string();

        let db = &ctx.data().database;

        let manager_role_id = sqlx::query!(
            "SELECT manager_role_id FROM manager_roles WHERE guild_id = $1",
            guild_id
        )
        .fetch_one(&db.pool)
        .await?
        .manager_role_id
        .parse::<u64>()?;

        let guild_id_u64: u64 = guild_id.parse()?;

        if ctx
            .author()
            .has_role(ctx, guild_id_u64, manager_role_id)
            .await?
        {
            return Ok(true);
        }

        ctx.send(
            CreateReply::default()
                .content("You do not have the required permissions to use this command.")
                .ephemeral(true),
        )
        .await?;

        return Ok(false);
    }

    pub async fn is_marshal_or_higher(ctx: Context<'_>) -> Result<bool, BotError> {
        let guild_id = ctx
            .guild()
            .ok_or("This command can only be used in a server.")?
            .id
            .to_string();

        let db = &ctx.data().database;

        let manager_role_id = sqlx::query!(
            "SELECT manager_role_id FROM manager_roles WHERE guild_id = $1",
            guild_id
        )
        .fetch_one(&db.pool)
        .await?
        .manager_role_id
        .parse::<u64>()?;

        let marshal_role_id = sqlx::query!(
            "SELECT marshal_role_id FROM config WHERE guild_id = $1",
            guild_id
        )
        .fetch_one(&db.pool)
        .await?
        .marshal_role_id
        .parse::<u64>()?;

        let guild_id_u64: u64 = guild_id.parse()?;

        if ctx
            .author()
            .has_role(ctx, guild_id_u64, manager_role_id)
            .await?
            || ctx
                .author()
                .has_role(ctx, guild_id_u64, marshal_role_id)
                .await?
        {
            return Ok(true);
        }

        ctx.send(
            CreateReply::default()
                .content("You do not have the required permissions to use this command.")
                .ephemeral(true),
        )
        .await?;

        return Ok(false);
    }

    pub async fn is_config_set(ctx: Context<'_>) -> Result<bool, BotError> {
        let guild_id = ctx
            .guild()
            .ok_or("This command can only be used in a server.")?
            .id
            .to_string();

        let db = &ctx.data().database;

        let config = sqlx::query!("SELECT * FROM config WHERE guild_id = $1", guild_id)
            .fetch_optional(&db.pool)
            .await?;

        if config.is_some() {
            return Ok(true);
        }

        ctx.send(
            CreateReply::default()
                .content("The bot configuration has not been set up for this server. Please ask a moderator to set it up.")
                .ephemeral(true),
        )
        .await?;

        Ok(false)
    }
}
