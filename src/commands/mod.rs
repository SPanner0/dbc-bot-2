pub mod manager_commands;
pub mod owner_commands;

use crate::{database::Database, tournament_model::TournamentModel, BotData, BotError};

/// A way to group commands together while side-stepping the need to use global variables.
///
/// Implementors of this trait can return a list of their commands from within their own module.
/// Typically, you would group commands by their required permissions or role.
///
/// Additionally, the implementors of this trait should not directly "own" the commands.
/// You should simply generate them by running the functions generated by the [`poise::command`](https://docs.rs/poise/latest/poise/macros/attr.command.html) macro and returning the vector.
/// This way, you only need to `pub` the implementor and not the commands themselves.
///
/// For more details on how this works, you can check the documentation for the [`poise::command`](https://docs.rs/poise/latest/poise/macros/attr.command.html#internals) macro.
///
/// For example, you can define a type to group Manager commands together.
/// ```
/// pub struct ManagerCommands; // This struct doesn't need to hold anything
///
/// impl CommandsContainer<PgDatabase, SingleElimTournament> for ManagerCommands {
///     fn get_commands_list(&self)
///         -> Vec<poise::Command<BotData<PgDatabase, SingleElimTournament>, BotError>> {
///         vec![very_important_manager_only_command()]
///     }
/// }
///
/// #[poise::command(slash_command, prefix_command)]
/// async fn very_important_manager_only_command(
///     ctx: Context<'_>,
/// ) -> Result<(), BotError> {
///     ctx.say("Wow, you're a manager, that's so cool!").await?;
///     Ok(())
/// }
/// ```
pub trait CommandsContainer<DB, TM>
where
    DB: Database,
    TM: TournamentModel,
{
    /// Retrive all the commands from a module, such as manager commands or marshal commands.
    fn get_commands_list() -> Vec<poise::Command<BotData<DB, TM>, BotError>>;
}
