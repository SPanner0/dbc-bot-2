// generated by `sqlx migrate build-script`

use sqlx::{postgres::PgPoolOptions, PgPool};
use std::env;
use std::time::Duration;
/// This is the build script that will be run by cargo when building the project.
/// It will run the migration files (usually table creation) before the project is built.
///
/// Note that Rust Analyzer will also run this whenever you save the project.
///
/// This script will not affect production whatsoever and is only used in development.
#[cfg(debug_assertions)]
#[tokio::main]
async fn main() {
    // trigger recompilation when a new migration is added
    println!("cargo:rerun-if-changed=migrations");

    // Load the environment variables from the .env file
    dotenv::dotenv().expect("unable to load .env file");
    println!("Loading .env file");

    let db_url = env::var("DATABASE_URL").expect("Missing `DATABASE_URL` env var.");

    match run_migrations(&db_url).await {
        Ok(_) => {
            println!("Successfully ran migrations.");
        }
        Err(e) => {
            eprintln!("Failed to run migrations: {:?}", e);
        }
    }
}
const MAX_ATTEMPTS: u8 = 100;
const ATTEMPT_DELAY: u64 = 2;
async fn run_migrations(db_url: &str) -> Result<(), sqlx::Error> {
    let mut attempts = 0;

    let db_pool = loop {
        if attempts >= MAX_ATTEMPTS {
            return Err(sqlx::Error::PoolClosed);
        }

        match connect_to_database(db_url).await {
            Ok(pool) => break pool,
            Err(e) => {
                attempts += 1;
                println!(
                    "Failed to connect to the database: {}. Retrying in {} seconds. Attempt {}/{}.",
                    e, ATTEMPT_DELAY, attempts, MAX_ATTEMPTS
                );
                tokio::time::sleep(Duration::from_secs(ATTEMPT_DELAY)).await;
            }
        }
    };

    // Run migrations
    sqlx::migrate!("./migrations").run(&db_pool).await?;

    println!("Migrations ran successfully!");

    Ok(())
}

async fn connect_to_database(db_url: &str) -> Result<PgPool, sqlx::Error> {
    let pool = PgPoolOptions::new()
        .max_connections(5) // Set the maximum number of connections
        .connect(db_url)
        .await;
    pool
}
